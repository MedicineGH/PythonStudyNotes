[TOC]

# python函数

## 函数 

> 函数：可以实现一些特定功能的小方法或是小程序。 
>
> python函数: 完成一定的功能,由若干语句组成的语句块, 函数名称, 参数列表构成, 它是组织代码的最小单位。

**作用** 

> 结构化变成对代码的最基本的封装, 一般按照功能组织一段代码。 
>
> 封装的目的为了复用, 减少冗余代码。 
>
> 代码更加简洁美观,可读易懂。

**总结**

> 函数是可调用的对象,callable()。 

### 函数参数 

1、参数调用时传入的参数要和定义的个数相匹配。 

2、位置参数：按照参数定义顺序传入实参。 

3、关键字参数: 使用形参的名字来传入实参的方式,如果使用了形参名字,那么传参顺序就可以和定义顺序不同。

注: **参数列表参数一般顺序是,普通参数,缺省参数,可变位置参数,keyword-only参数(可带缺省值),可变关键字参数.**

### 函数参数默认值 

> 参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值。
>
> 参数非常多时,并不需要用户每次都输入所有的参数,简化函数调用。 

### 可变参数 

**可变参数分为位置可变参数和关键字可变参数。**

> 一个形参可以匹配任意个参数。 
>
> 在形参前使用 ` *` 表示该形参是可变参数,可以接收多个实参。
> 收集多个实参为一个**元组**。
>
> ```python 
> def func(*形参)：  
> 	pass  
> func(实参) 
> ```

**关键字参数的可变参数**

> 形参前使用 `**` 符号,表示可以接收多个关键字参数。 
>
> 收集的实参名称和值组成一个**字典**。

**可变参数混合使用** 

> 混合使用参数时,可变参数要放在参数列表的最后,普通参数需要放到参数列表前面,位置可变参数需要放在关键字可变参数之前。
>
> ```python 
> def showconfig(username,password,**kwargs) 
> def showconfig(username,*args,**kwargs)
> def showconfig(username,password,**kwargs,*args)
> ```

### keyword-only参数

注: python3.x 新加入。

> 在一个带星号的参数后, 或者一个位置可变参数后, 出现的普通参数即 keyword-only 参数。
>
> ```python 
> # 例 
> def fn(*,x,y): 
>     pass  
> fn(x=4, y=5)
> ```

### 参数解构

> 给函数提供实参时,可在集群类型前使用*或**,把集群类型的元素解开,提取出所有元素作为函数的实参。
>
> 非字典类型使用 `*` 解构成位置参数。
>
> 字典类型使用 `**` 解构成关键字参数。
>
> 提取出来的元素数目要和参数的要匹配, 也要和参数的类型匹配。

```python 
In [1]: import random

In [2]: def double_values(*nums):
   ...:     print(nums)
   ...:     return max(nums), min(nums)
   ...:

In [3]: print(*double_values(*[random.randint(10, 20) for _ in range(10)]))  # 两次解构.
(15, 12, 15, 13, 20, 11, 13, 20, 18, 13)
20 11

In [4]:
```



## 插入排序



## 函数的返回值, 作用域 

### 函数返回值 

> 作用: 结束函数调用和返回返回值。
>
> `返回值` 使用return语句返回。 
>
> 所有函数都有函数值,如果没有 return 语句,隐式调用 `return None`。 
>
> 一个函数可以存在多个return语句, 但是只有一条可以被执行。
>
> 如果函数执行了return语句,函数就会返回,当前被执行的return语句之后的其他语句就不会被执行。

### 函数嵌套 

> 函数有可见范围,这就是 `作用域` 的概念。
> 内部函数不能被外部直接使用,会抛异常 NameError 。

### 函数作用域

> 作用域: 一个标识符的可见范围即标识符的作用域.一般常说的是变量的作用域。 
>
> - 全局作用域: 在整个程序运行环境中都可见。 
>
> - 局部作用域: 在函数, 类等内部可见。 
>
>   局部变量使用范围不能超过其所在的局部作用域。
>
>   如果是多层函数嵌套，外层变量作用域在内层作用域可见。 

**global - 全局变量**  

> 使用 global 关键字的变量, 将函数内部的变量声明为函数外的全局作用域中的变量。
>
> 如果全局作用域中没有该局部作用域定义的变量，使用global后，相当于在全局作用域中定义且赋值了一个变量对应的值。如果全局作用域中已有该变量，则会覆盖。
>
> global使用原则: 
>
> - 外部作用域变量在内部作用域可见, 但也不要在这个内部的局部作用域中直接使用, 因为函数的目的就是为了封装, 尽量与外界隔离。
> - 如果函数需要使用外部全局变量, 使用函数的形参传参解决。

### 闭包 

> 自由变量: 未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量。
> 闭包: 是一个概念, 出现在嵌套函数中, **内层函数引用到外层函数的自由变量**, 就形成了闭包, JS就是如此。 

示例: 

```python 
In [1]: def func1():
    ...:     count = 0
    ...:     def inc1():
    ...:         count += 1  # 该处报错问题, 使用global可以解决,但这样使用的是全局变量,而不是闭包。 
    ...:         return count
    ...:     return inc
    ...:

In [2]: 
```

该counter函数会报错 `UnboundLocalError` 。

```python 
In [3]: def func2():
   ...:     count = [0]
   ...:     def inc2():
   ...:         count[0] += 1  # 该处的使用方式为count的元素修改值,而不是重新定义变量。 
   ...:         return count[0]
   ...:     return inc
    
In [4]:
```

该counter函数不会报错。

**总结** 

> 1、内部函数，不修改全局变量可以访问全局变量；在内部函数里面修改同名全局变量，则python会认为该变量就是一个局部变量；在内部函数修改同名全局变量之前调用变量名称，则引发 `UnboundLocalError`。
>
> 2、在程序中设置的 count 属于全局变量, 而在嵌套函数中没有 count 的定义,根据python访问局部变量和全局变量的规则：当搜索一个变量的时候，python先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，python就在全局变量中找这个变量，如果找不到抛出异常(NameError或者UnboundLocalError，这取决于python版本。) 
>
> 3、如果内部函数有引用外部函数的同名变量或者全局变量, 并且对这个变量有修改, 那么python会认为它是一个局部变量,又因为函数中没有 count 的定义和赋值, 所以报错。

### nonlocal 关键字

> 用来在函数或其他作用域中使用外层(非全局)变量。
>
> 使用了nonlocal关键字, 即把变量标记为在上级的局部作用域中定义的变量, 但不能是全局作用域中定义的.

```python 
In [1]: def counter():
   ...:     count = 0
   ...:     def inc():
   ...:         nonlocal count
   ...:         count += 1
   ...:         return count
   ...:     return inc
   ...:

In [2]: res = counter()

In [3]: res()
Out[3]: 1

In [4]: res()  # 变量count的值伴随着这个函数对象的整个生命周期。
Out[4]: 2

In [5]:
```

### 默认值的作用域 

示例1： 

```python 
In [1]: def foo(lst=[]):
   ...:     lst.append(1)
   ...:     return lst
   ...:

In [2]: foo.__defaults__
Out[2]: ([],)

In [3]: foo()
Out[3]: [1]

In [4]: foo.__defaults__
Out[4]: ([1],)

In [5]: foo()
Out[5]: [1, 1]

In [6]: foo.__defaults__
Out[6]: ([1, 1],)
# 函数也是对象,python把函数的默认值放在了属性中,这个属性就伴随着这个函数对象的整个生命周期。
```

示例2：引用类型

```python 
In [7]: def foo(xyz=[], u='abc', z=123):
    ...:     xyz.append(1)
    ...:     return xyz
    ...:

In [8]: foo(), id(foo)
Out[8]: ([1], 2239176151928)

In [9]: foo.__defaults__
Out[9]: ([1], 'abc', 123)

In [10]: foo(), id(foo)
Out[10]: ([1, 1], 2239176151928)

In [11]: foo.__defaults__
Out[11]: ([1, 1], 'abc', 123)

In [12]:
# 函数地址并没有变,即函数这个对象的地址没有变,调用它,它的属性__defaults__中使用元组保存所有默认值. 
# xyz默认值是引用类型,引用类型的元素变动,并不是元组的变化。 
```

示例3：非引用类型

```python 
In [1]: def foo(w,u='abc',z=123):
   ...:     u='xyz'
   ...:     z=789
   ...:     print(w,u,z)
   ...:

In [2]: foo.__defaults__
Out[2]: ('abc', 123)

In [3]: foo('amesy')
amesy xyz 789

In [4]: foo.__defaults__
Out[4]: ('abc', 123)

# 属性__defaults__中使用元组保存所有默认值,__defaults__不会因为在函数体内使用了它而发生改变。 
# 可变类型默认值,如果使用默认值,就可能修改这个默认值。
# 有时候这个特性是好的,有时候不然,有副作用。
```

示例4：按需改变

```python 
def foo(xyz=[], u='abc', z=123):
	xyz = xyz[:] # 影子拷贝.
	xyz.append(1)
	print(xyz)

# 使用影子拷贝创建一个新的对象,永远不能改变传入的参数。
```

```python 
def foo(xyz=None, u='abc', z=123):
    if xyz is None:
        xyz = []
    xyz.append(1)
    print(xyz)
    
# 通过值的判断就可以灵活的选择创建或修改传入对象。 
# 这种方式灵活,应用广泛。很多函数的定义,都会使用None这个不可变的值作为默认参数,算是一种惯用法。
```

### 变量名解析原则LEGB

- Local, 即本地作用域, 局部作用域的local命名空间。函数调用时创建, 调用结束消亡。 
- Enclosing, python2.2时引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间。 
- Global, 全局作用域, 即一个模块的命名空间。模块被import时创建, 解释器退出时消亡。 
- Build-in, 内置模块的命名空间, 生命周期从python解释器启动时创建到解释器退出时消亡。
  - 例如print(open),print和open都是内置的变量. 

   所以一个名词的查找顺序就是 `LEGB` 。

   图示:

  ​	![LEGB](http://static.open-open.com/lib/uploadImg/20150209/20150209125753_178.jpg)

### 函数的销毁

全局函数销毁: 

- 重新定义同名函数。 
- del语句删除函数对象。
- 程序结束时自然消亡。 

局部函数销毁: 

- 重新在上级作用域定义同名函数。


- del语句删除函数对象。
- 上级作用域销毁时。

## 树 



## 函数代码的执行流程 

> 函数的执行总是从程序的第一行代码开始的，从上到下，从左到右，从第一条语句开始按顺序依次执行。
>
> 函数定义并不会改变程序的执行流程，但应该注意函数代码块中的语句并不是立即就执行的，而是等到函数被程序调用时才会执行。
>
> 函数调用可以看作程序执行流程中的一个迂回路径，遇到函数调用时，并不会直接继续执行下一条语句，而是跳到函数体的第一行，继续执行完函数代码块的所有语句，再跳回到原来离开的地方。
>
> 函数代码块中也可以调用其他函数，当程序流程运行到一个函数之中时，可能需要执行其他函数中的语句; 但当执行那个函数中的语句时，又可能再需要调用执行另一个函数的语句。
>
> Python对于它运行到哪里有记录，所以在每个函数执行结束之后，程序都能跳回到它离开的那个地方, 直至执行到整个程序的结尾，才会结束程序。
>

动态演示函数的执行过程: <http://pythontutor.com/visualize.html#mode=edit>

## 递归函数 

> ​    函数直接或间接调用自身即递归。
>
> ​    递归需要有边界条件,递归前进段, 递归返回段。 
>

递归动态图示:  http://codingpy.com/article/10-gifs-to-understand-some-programming-concepts/

示例：斐波那契数列 

```python 
# 如果设F(n)为该数列的第n项,(n∈N-1),那么这句话可以写成:F(n) = F(n-1) + F(n-2) 
def fn(n): 
    return 1 if n < 2 else fn(n-1) + fn(n-2) 
```

实例: 阶乘的递归 

```python 
def fn(n): 
	if n == 0:
		raise ValueError('0 is invaild') 
	elif n == 1: 
		return 1
	return n * fn(n-1)
```

注: 

- 递归一定要有退出条件,递归调用一定要执行到这个退出条件；没有退出条件的递归调用就是无限调用。
- python对递归调用的深度做了限制, 超过递归深度限制, 会抛异常。`sys.getrecursionlimit() `

**递归函数的性能**

- 深度越深, 效率越低。
- 递归有深度限制, 如果递归复杂, 函数反复压栈, 栈内存很快就溢出了。  

示例：对斐波那契数列的改进 

```python 
pre = 0
cur = 1
def fib(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib(n-1, pre, cur)
```

**间接递归** 

> 通过别的函数调用了函数自身, 即间接递归。 
> 在复杂代码情况下发生间接递归调用是非常危险的, 要用代码规范来避免这种递归调用的发生。 

**总结** 

递归是一种很自然的表达,符合逻辑思维。
递归相对运行效率低,每一次调用函数都要开辟栈帧。
递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了。
如果是有限次数的递归,可以使用递归调用,或者使用循环代替,循环代码稍微要复杂一些,但是只要不是死循环,可以多次迭代直至算出结果。
绝大多数递归,都可以使用循环实现。
即使递归代码很简洁,但是能不用递归就不要用。

## 高阶函数

> 概念: 把函数当成参数传递的一种函数。 
>
> 满足要求: 接收一个或多个函数作为参数，输出一个函数。(两者满足其一即可)

示例： 

```python 
In [1]: def add(x, y, func):
   ...:     return func(x) + func(y)
   ...:

In [2]: add(-8, 11, abs)
Out[2]: 19
```

示例: 计数器 

```python 
In [9]: def counter(base):
   ...:     def inc(step=1):
   ...:         nonlocal base  # 该行没有的话会报错。
   ...:         base += step
   ...:         return base
   ...:     return inc
   ...:

In [10]: print(counter(5)())
6
In [11]:
```

分析: 

- 该 counter 是一个高阶函数,  第4行base被重新赋值, 所以需要nonlocal关键字。 
- 对于 `f1 = counter(5)` 和 `f2 = counter(5)` , 值相同但内存地址不同。因为 inc 是 counter内的函数, 每次调用counter时, inc都要在栈上重新生成, 故内存地址不相等。


示例: 自定义 sort 函数 

>   排序问题: 仿照内建函数sorted, 实现一个sort函数(不使用内建函数), 且能够为列表元素排序。 
>   思路: 
>
>   -   内建函数sorted会返回一个新的列表,可以设置升序或降序,设置的排序的函数,自定义的sort函数也要实现这个功能。
>   -   新建一个列表, 遍历原列表, 和新列表的值依次比较决定如何插入到新列表中。 

```python 
def sort(iterable, reverse=False):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            bol = x > y if reverse else x < y
            if bol:
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst, reverse=True))
```

```python 
def sort(iterable, fn = lambda x, y: x < y):
    ret = []
    for x in iterable:
        for k, y in enumerate(ret):
            if fn(x, y):
                ret.insert(k, x)
                break
        else:
            ret.append(x)
    return ret

lst = [1, 9, 5, 3, 4]
print(sort(lst))
```








## 匿名函数 

> 匿名函数,即没有名字的函数。 
>
> python借助 lambda 表达式构建匿名函数；它只能写在一行上,被称为单行函数。
>
> 格式:  `lambda 参数列表: 表达式 `
>
> - 参数列表不需要小括号。
> - 冒号用来分割参数列表和表达式。
> - 不需要使用return,表达式的值,就是匿名函数返回值. 
> - lambda表达式(匿名函数)只能写在一行上,被称为单行函数. 

```python 
In [4]: print((lambda x, *, y=30: x + y)(5, y=10))
15

In [5]: print((lambda *args: (x for x in args))(*range(5)))
<generator object <lambda>.<locals>.<genexpr> at 0x000001E699027888>

In [6]: print((lambda *args: [x for x in args])(*range(5)))
[0, 1, 2, 3, 4]

In [9]: print((lambda *args: {x for x in args})(*range(5)))
{0, 1, 2, 3, 4}
```

## map()函数 

> python内置的一个高阶函数, 它接收一个函数和一个列表, 并且把列表的元素以此传递给该函数，然后返回一个该函数处理完所有列表元素的迭代器。

```python 
In [11]: list(map(lambda x: x**2, [1, 2, 3, 4]))
Out[11]: [1, 4, 9, 16]

In [12]:
```

示例: 在高阶函数传参时,使用lambda表达式, 简化代码。

```python
In [14]: [x for x in (lambda *args: map(lambda x: x**2, args))(*range(5))]
Out[14]: [0, 1, 4, 9, 16]
```

```python
In [15]: [x for x in (lambda *args: map(lambda x: (x+1,args), args))(*range(5))]
Out[15]:
[(1, (0, 1, 2, 3, 4)),
 (2, (0, 1, 2, 3, 4)),
 (3, (0, 1, 2, 3, 4)),
 (4, (0, 1, 2, 3, 4)),
 (5, (0, 1, 2, 3, 4))]
```

## filter()函数

>   python内置的高阶函数, 过滤可迭代对象的元素, 返回一个迭代器。用法和map函数类似。 

```python 
In [1]: list(filter(lambda x: x %3 == 0, [0, 3, 4, 7, 9]))
Out[1]: [0, 3, 9]

In [2]:
```

## 柯里化Currying 

>   指将原来接收两个参数的函数变成新的接收一个参数的函数的过程, 新的函数返回一个以原有第二个参数为参数的函数。  
>   即 `z = f(x, y)` 转换成 `z = f(x)(y)` 的形式。  

示例: 通过嵌套函数就可以把函数转换为柯里化函数。

```python 
def add(x, y):
    return x + y

print(add(5, 4))
 
# 以上代码通过柯里化, 改为如下: 
def add(x):
    def _add(y):
        return x + y
    return _add

print(add(5)(4))
```

# 生成器 

- 带有 **yield** 关键字的的函数在 Python 中被称之为 generator(生成器)。Python 解释器会将带有 **yield** 关键字的函数视为一个 generator 来处理。一个函数或者子程序都只能 return 一次，但是一个生成器能暂停执行并返回一个中间的结果 —— 这就是 yield 语句的功能 : 返回一个中间值给调用者并暂停执行。
- **生成器其实是一种特殊的迭代器**，这句话反过来不成立。不过这种迭代器更加优雅, 它不需要再像上面的类一样写 `__iter__()`和 `__next__()`方法了，只需要一个 `yiled`关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。



```python 
# generator
def arr(num):
    n, a, b = 0, 0, 1
    while n < num:
        yield b
        a, b = b, a+b
        n += 1
res = arr(5)
for _ in range(5):
    print(next(res))
```

**分析：生成器 arr() 的执行过程**

- 执行语句 res = arr(5) 时，并不会马上执行 arr() 函数的代码块，而是首先返回一个 iterable 对象。
- 在 for 循环语句执行时，才会执行 fab() 函数的代码块。 
- 执行到语句 yield b 时，fab() 函数会返回一个迭代值，直到下次迭代前，程序流会回到 yield b 的下一条语句继续执行，然后再次回到 for 循环，如此迭代直到结束。看起来就好像一个函数在正常执行的过程中被 yield 中断了数次，每次中断都会通过 yield 返回当前的迭代值。 
- 由此可以看出，**生成器通过关键字 yield 不断的将迭代器返回到内存进行处理，而不会一次性的将对象全部放入内存，从而节省内存空间**。从这点看来生成器和迭代器非常相似，但如果更深入的了解的话，其实两者仍存在区别。

## 生成器函数 

> 函数体中包含yield语句的函数,返回生成器对象. 
>
> - 生成器对象,是一个可迭代对象, 也是一个迭代器。
> - 生成器对象,是延迟计算,惰性求值的。
>
> 生成器函数等价于生成器表达式,只不过生成器函数可以更加的复杂。
>
> 在一个生成器函数中, 如果没有 return, 则默认执行至函数完毕, 如果在执行过程中 return, 则会直接抛出 `StopIteration` 来终止迭代。

判断一个函数是否为generator函数, 使用isgeneratorfunction判断。

```python 
In [1]: def func(b):
    ...:     yield b
    ...:
    ...:

In [2]: from inspect import isgeneratorfunction

In [3]: isgeneratorfunction(func)
Out[3]: True
```

**注意区分 func 和 func(b)** ，`func` 是一个 generator function，而 `func(b)` 是调用 fab 返回的一个 generator。 

```python 
In [4]: from collections import Iterable

In [5]: isinstance(func, Iterable)
Out[5]: False

In [6]: isinstance(func(4), Iterable)
Out[6]: True

In [7]: 
```

示例: 处理递归问题。

```python  
def fib():
    x = 1
    y = 1
    while True:
        yield x
        x, y = y, x+y
foo = fib()
for _ in range(10):
    print(next(foo))
```

```python 
pre = 0
cur = 1
print(pre, cur, end = ' ')

def fib1(n, pre=0, cur=1):
    pre, cur = cur, pre + cur
    print(cur, end = ' ')
    if n == 2:
        return
    fib1(n-1, pre, cur)
    
fib1(10)
```

## 生成器表达式 

> 生成器表达式是列表解析的扩展，就如上所述：生成器是一个特定的函数, 允许返回一个中间值，然后挂起代码的执行，稍后再恢复执行。列表解析的不足在于，它必须一次性生成所有的数据，用以创建列表对象，所以不适用于迭代大量的数据。 **生成器表达式则通过结合列表解析和生成器来解决这个问题。**

**语法** 

```python 
# 列表解析式 
[expr for iter_var in iterable if cond_expr] 

# 生成器表达式 
(expr for iter_var in iterable if cond_expr)
```

**总结** 

> 两者的语法非常相似，但生成器表达式返回的不是一个列表类型对象，而是一个生成器对象，生成器是一个内存使用友好的结构。在需要迭代一个对象时，应该优先考虑使用生成器替代迭代器，使用生成器表达式替代列表解析。当然这并不是绝对的。迭代器和生成器是 Python 很重要的特性，对其有很好的理解能够写出更加 Pythonic 的代码。

## 协程coroutine: 

> 属于生成器的高级用法。 
>
> 比进程,线程轻量级。 
>
> 是在用户空间调度函数的一种实现。 
>
> python3 asyncio 就是协程实现,已经加入到标准库。
>
> python3.5使用 `async`, `await` 关键字直接原生支持协程。 

**协程调度实现思路**

>   有2个生成器A, B, next(A)后,A执行到yield语句暂停, 然后执行next(B), B执行到yield语句也暂停, 就再次调用next(A), 然后再调用next(B), 周而复始, 就实现了调度的效果。 

- 可以引入调度的策略来实现切换的方式。 
- 协程是一种非抢占式调度。
- 另一个 yield 的例子来源于文件读取。如果直接对文件对象调用 read() 方法, 会导致不可预测的内存占用。好的方法是利用固定长度的缓冲区来不断读取文件内容。
- 通过 yield，我们不再需要编写读文件的迭代类，就可以轻松实现文件读取。

```python
def read_file(fpath):
   BLOCK_SIZE = 1024
   with open(fpath, 'rb') as f:
       while True:
           block = f.read(BLOCK_SIZE)
           if block:
               yield block
           else:
               return 
```

### yield from 

>   `yield from` 是 python3.3 出现的新的语法。
>
>    `yield from iterable` 是 `for item in iterable: yield item` 形式的语法糖。

```python 
def inc():
    for x in range(10):
        yield x

# 等价于

def inc():
    yield from range(10)

foo = inc()
for _ in range(10):
    print(next(foo))
```

# 装饰器 

## 无参装饰器 

```python 
def add(x, y):
    return x+y

def func(fn, *args, **kwargs):
    print('begin')
    res = fn(*args, **kwargs)
    print('end')
    return res

print(func(add, 4, y=5))
```

## 装饰器语法糖

>   装饰器(无参)：
>
>   -   是一个函数; 
>   -   函数作为它的形参; 
>   -   返回值也是一个函数; 
>   -   使用 `@FunctionName` 方式, 简化调用; 
>   -   可以使用特殊属性 `__name__` 查看函数名。
>
>   装饰器和高阶函数：
>
>   -   装饰器是高阶函数, 但装饰器是对传入函数的功能的装饰(即功能增强). 

```python 
import datetime
import time

def logger(fn):
    def wrap(*args, **kwargs):
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)
    return wrap

@logger  # add = logger(add)

def add(x, y):
    time.sleep(1)
    return x + y

print(add(4, 5))
```

## 文档字符串

>   在函数语句块的第一行, 且习惯是多行的文本, 一般使用三引号。   
>
>   惯例是首字母大写, 第一行写概述, 然后空一行, 第三行写详细描述。 
>
>   可以使用特殊属性 `__doc__` 访问这个文档。 

```python 
def add(x, y):
    """ This is a function addition"""
    return x + y

print('result: {}, function_name: {}, Document_desc: {}'.format(add(4, 5), add.__name__, add.__doc__)
```

```python
import datetime
import time

def copy_properties(src, dst):
    dst.__name__ = src.__name__
    dst.__doc__ = src.__doc__

def logger(fn):
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    copy_properties(fn, wrap)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

上面的函数, 如果没有 `copy_properties`，原函数 `add`对象的属性都会被替换成 `wrap` ; 因此提供 `copy_properties`函数, 被封装函数属性 –> copy -> 包装函数属性。通过 `copy_properties` 函数用被包装函数的属性覆盖掉包装函数。凡是被装饰的函数都需要复制这些属性, 这个函数很通用, 可以将复制属性的函数构建成装饰器函数, 带参装饰器。 

## 带参装饰器 

>   它是一个函数, 函数作为它的形参。返回值是一个不带参的装饰器函数, 使用 `@functionname (参数列表)` 方式调用。可以看做在装饰器外层又加了一层函数. 

示例: 将记录的功能提取出来,就可以通过外部提供的函数来灵活控制输出。

```python 
import datetime
import time

def copy_properties(src):
    def _copy(dst):
        dst.__name__ = src.__name__
        dst.__doc__ = src.__doc__
        return dst
    return _copy

def logger(fn):
    @copy_properties(fn)
    def wrap(*args, **kwargs):
        '''this is wrap function.'''
        print('begin')
        start_time = datetime.datetime.now()
        res = fn(*args, **kwargs)
        end_time = (datetime.datetime.now() - start_time).total_seconds()
        return 'result: {}, time: {}'.format(res, end_time)

    return wrap

@logger  # add = logger(add)

def add(x, y):
    '''this is add function.'''
    time.sleep(1)
    return x + y

print(add(4, 5), add.__name__, add.__doc__)
```

## functools函数 

>   Python自带的 `functools` 模块提供了一些常用的高阶函数，也就是用于处理其它函数的特殊函数。换言之，就是能使用该模块对可调用对象进行处理。

### update_wrapper()

该函数用于更新包装函数（wrapper），使它看起来像原函数一样, 类似于上面代码中的 `copy_properties` 。该函数主要用在装饰器函数的定义中，置于包装函数之前。如果没有对包装函数进行更新，那么被装饰后的函数所具有的元信息就会变为包装函数的元信息，而不是原函数的元信息。

```python 
# 语法 
update_wrapper(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',)) 
```

可选的参数是一个元组，`assigned` 元组指定要直接使用原函数的值进行替换的属性，`updated` 元组指定要对照原函数进行更新的属性。这两个参数的默认值分别是模块级别的常量：`WRAPPER_ASSIGNMENTS` 和 `WRAPPER_UPDATES`。前者指定了对包装函数的 `__name__`, `__module__`, `__doc__` 属性直接赋值，而后者指定了对包装函数的 `__dict__` 属性进行更新。

示例：属性复制.

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return functools.update_wrapper(wrapper, fn)  # 复制函数属性, 功能类似functools.wraps.
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__, add.__wrapped__, add.__dict__, sep='\n')  
```

### partial()

```python 
# 语法
partial(func, *args, **keywords)
```

-   该函数返回一个 partial 对象, 调用该对象的效果相当于调用 func 函数, 并传入位置参数 args 和关键字参数 keywords 。如果调用该对象时传入了位置参数，则这些参数会被添加到 args 中。如果传入了关键字参数，则会被添加到 keywords 中。 
-   也称偏函数, 把函数部分的参数固定下来, 相当于为部分的参数添加了一个固定的默认值, 形成一个新的函数并返回, 从partial生成的函数, 是对原函数的封装。

示例： 

```python 
import functools

def add(x, y, *args) -> int:
    print(args)
    return x + y

newadd = functools.partial(add, 1,3,6,5)
print(newadd(7))
print(newadd(7, 10))
# print(newadd(9, 10, y=20, x=26))  # 报错.
print(newadd())
```

### wraps()

```python 
# 语法 
functools.wraps(wrapped[, assigned][, updated])
```

`wraps()` 简化了 `update_wrapper()` 函数的调用。

它等价于 `partial(update_wrapper, wrapped=wrapped, assigned, updated=updated)`。

示例： 

```python 
import datetime, time, functools

def logger(duration, func=lambda name, duration: print('{} took {}s'.format(name, duration))):
    def _logger(fn):
        @functools.wraps(fn)  # 属性复制.
        def wrapper(*args,**kwargs):
            start = datetime.datetime.now()
            ret = fn(*args,**kwargs)
            delta = (datetime.datetime.now() - start).total_seconds()
            if delta > duration:
                func(fn.__name__, duration)

            return ret
        return wrapper
        # return functools.update_wrapper(wrapper, fn)
    return _logger

@logger(1)  # add = logger(1)(add)

def add(x,y):
    time.sleep(1)
    return x + y

print(add(5, 6), add.__name__,add.__dict__, sep='\n')
```

### functools.lru_cache()

```python 
# 语法 
lru_cache(maxsize=128, typed=False)
```

>   `least-recently-used` 装饰器。 lru即最近最少使用，cache即缓存。 
>
>   如果 maxsize 设置为None, 则禁用 LRU 功能, 并且缓存可无限制增长, 当 maxsize 是2的幂的时候, LRU 功能执行得最好。  
>
>   如果 typed 设置为 True , 则不同类型的函数参数将单独缓存。例: f(3) 和 f(3.0) 将被视为具有不同结果的不同调用。

示例：斐波那契数列递归方法的改造. 

```python 
import functools

@functools.lru_cache()  # 最大限度缓存.
def fn(n):
    if n < 2:
        return n
    return fn(n-1) + fn(n-2)

print([fn(x) for x in range(100)])
```

**lru_cache装饰器应用**

>   使用前提： 
>
>   -   同样的函数参数一定得到同样的结果；
>   -   函数执行时间很长,且要多次执行。
>
>   本质是函数调用的参数 -> 返回值. 
>
>   缺点： 
>
>   -   不支持缓存过期,key无法过期 失效。
>   -   不支持清除操作。
>   -   不支持分布式,是一个单机的缓存。
>
>   适用场景, 单机上需要空间换时间的地方,可以用缓存来将计算变成快速的查询。

## 参数注解 

python是动态语言, 变量随时可以被赋值, 且能赋值为不同的类型; 
python不是静态编译型语言, 变量类型是在运行时决定的; 
动态语言很灵活, 但是也有弊端. 
难发现: 由于不做任何类型检查, 直到运行期问题才显现出来, 或者线上运行时才会暴露出问题; 

# 难使用: 函数的使用者看到函数的时候, 并不知道你的函数设计,不知道应该传入什么类型的数据.
解决这种动态语言定义的弊端:  
1.增加文档Documentation String. (__doc__)
惯例, 非强制标准. 
函数定义更新与文档更新未必同步.
2.函数注解.
python3.5引入,
对函数的参数进行类型注解; 
只对函数参数做一个辅助说明, 并不对函数参数进行类型检查. 
提供第三方工具, 做代码分析, 发现隐藏的BUG. 
函数注解信息,保存在 __annotations__属性中. 
3.变量注解.
python3.6引入. 
i:int = 3 

